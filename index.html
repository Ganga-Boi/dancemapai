<!DOCTYPE html>
<html lang="da">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WYGJJJV2E6"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-WYGJJJV2E6');
    </script>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DanceMap AI</title>

    <style>
        body {
            margin: 0;
            background: linear-gradient(180deg, #022237, #011520);
            font-family: "Segoe UI", sans-serif;
            color: #fff;
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .topbar {
            height: 64px;
            background: #011c2b;
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 20px;
            font-weight: 600;
            letter-spacing: 1px;
            box-shadow: 0 0 10px #00000070;
        }

        .topbar img {
            width: 38px;
            height: 38px;
            margin-right: 10px;
            border-radius: 50%;
            object-fit: cover;
        }

        #chat {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 100px;
        }

        .message {
            display: flex;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 12px;
        }

        .message img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .bubble {
            background: rgba(255, 255, 255, 0.08);
            padding: 14px 18px;
            border-radius: 16px;
            max-width: 70%;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message.user .bubble {
            background: #2a5a7a;
        }

        .input-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #011c2b;
            padding: 16px;
            display: flex;
            gap: 10px;
            box-shadow: 0 -2px 10px #00000070;
        }

        #userInput {
            flex: 1;
            padding: 12px 16px;
            border-radius: 24px;
            border: 1px solid #2a5a7a;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 15px;
            outline: none;
        }

        #userInput::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        #sendBtn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #4a90e2;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #sendBtn:hover {
            background: #357abd;
        }

        .typing {
            display: none;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .typing.active {
            display: flex;
        }

        .typing img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }

        .typing-dots {
            background: rgba(255, 255, 255, 0.08);
            padding: 14px 18px;
            border-radius: 16px;
            display: flex;
            gap: 6px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
            40% { opacity: 1; transform: scale(1); }
        }

        a {
            color: #4a90e2;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* FAB Button - Floating Action Button */
        .fab {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #4a90e2;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .fab:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(74, 144, 226, 0.6);
            background: #357abd;
        }

        .fab:active {
            transform: translateY(-1px);
        }

        /* Mobile optimering */
        @media (max-width: 768px) {
            #chat {
                padding: 15px;
                padding-bottom: 90px;
            }

            .bubble {
                max-width: 85%;
                font-size: 14px;
            }

            .topbar {
                height: 56px;
                font-size: 18px;
            }

            .topbar img {
                width: 32px;
                height: 32px;
            }

            .message img {
                width: 36px;
                height: 36px;
            }

            .fab {
                bottom: 80px;
                right: 16px;
                width: 52px;
                height: 52px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="topbar">
            <img src="dancemap-icon.png" alt="DanceMap AI" />
            <span>DanceMap AI</span>
        </div>

        <div id="chat">
            <div class="message bot">
                <img src="dancemap-icon.png" alt="Bot" />
                <div class="bubble">Velkommen til DanceMap AI! ğŸ’ƒ

Find salsa, bachata, kizomba og andre dance events i Danmark!

ğŸ” SÃ¸g: "salsa i kÃ¸benhavn" eller "events i weekenden"
ğŸ“ TilfÃ¸j manglende event: Skriv "tilfÃ¸j event"

Hvad leder du efter? ğŸ˜Š</div>
            </div>
        </div>

        <div class="typing" id="typing">
            <img src="dancemap-icon.png" alt="Bot" />
            <div class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>

        <!-- FAB Button -->
        <button class="fab" onclick="startEventSubmission()" title="TilfÃ¸j event">
            ğŸ“
        </button>

        <div class="input-area">
            <input
                type="text"
                id="userInput"
                placeholder="Skriv en besked..."
                autocomplete="off"
            />
            <button id="sendBtn" onclick="sendMessage()">â¤</button>
        </div>
    </div>

    <script>
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwLZ-irHmdb-Fqj71-bjByWeocCtx0aWOq3l-fOy3g1nb7hMgINivHm8qpdy8v_bsVM/exec";
        let sessionId = generateSessionId();
        
        // Guided submission state
        let submissionState = {
            active: false,
            step: 0,
            data: {}
        };

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Start guided event submission from FAB button
        function startEventSubmission() {
            submissionState = {
                active: true,
                step: 1,
                data: {}
            };
            
            addMessage("ğŸ“ Lad os tilfÃ¸je et event!\n\nHvilken dato er eventet?\n(fx '6. december' eller '2024-12-06')", "bot");
            document.getElementById("userInput").focus();
        }

        document.getElementById("userInput").addEventListener("keypress", function(e) {
            if (e.key === "Enter") {
                e.preventDefault();
                sendMessage();
            }
        });

        async function sendMessage() {
            const input = document.getElementById("userInput");
            const message = input.value.trim();

            if (!message) return;

            addMessage(message, "user");
            input.value = "";
            
            // Handle guided submission flow
            if (submissionState.active) {
                handleGuidedSubmission(message);
                return;
            }
            
            showTyping(true);

            try {
                const response = await fetch(`${SCRIPT_URL}?message=${encodeURIComponent(message)}&sessionId=${sessionId}`);
                const data = await response.json();

                showTyping(false);
                addMessage(data.reply, "bot");

            } catch (error) {
                showTyping(false);
                addMessage("Beklager, jeg kunne ikke forbinde til serveren. PrÃ¸v igen! ğŸ”„", "bot");
                console.error("Error:", error);
            }
        }
        
        function handleGuidedSubmission(message) {
            const step = submissionState.step;
            
            if (step === 1) {
                // Dato
                submissionState.data.dato = message;
                submissionState.step = 2;
                addMessage(`âœ… ${message}\n\nHvilket tidspunkt starter det?\n(fx '20:00' eller '19.30')`, "bot");
            }
            else if (step === 2) {
                // Tid
                submissionState.data.tid = message;
                submissionState.step = 3;
                addMessage(`âœ… ${message}\n\nHvilken type event?\nâ€¢ Salsa\nâ€¢ Bachata\nâ€¢ Kizomba\nâ€¢ Salsa Bachata\nâ€¢ Andet`, "bot");
            }
            else if (step === 3) {
                // Type
                submissionState.data.type = message;
                submissionState.step = 4;
                addMessage(`âœ… ${message}\n\nHvad hedder stedet?\n(fx 'Nordhus' eller 'Kedelhallen')`, "bot");
            }
            else if (step === 4) {
                // Sted
                submissionState.data.sted = message;
                submissionState.step = 5;
                addMessage(`âœ… ${message}\n\nHvilken by?\n(fx 'KÃ¸benhavn' eller 'Aarhus')`, "bot");
            }
            else if (step === 5) {
                // By
                submissionState.data.by = message;
                submissionState.step = 6;
                
                const summary = `âœ… ${message}\n\nPerfekt! Her er hvad jeg har:\n\n` +
                               `ğŸ“… ${submissionState.data.dato} kl. ${submissionState.data.tid}\n` +
                               `ğŸ’ƒ ${submissionState.data.type}\n` +
                               `ğŸ“ ${submissionState.data.sted}\n` +
                               `ğŸ™ï¸ ${submissionState.data.by}\n\n` +
                               `Er det korrekt? (ja/nej)`;
                addMessage(summary, "bot");
            }
            else if (step === 6) {
                // BekrÃ¦ftelse
                if (message.toLowerCase() === 'ja' || message.toLowerCase() === 'yes') {
                    submitEvent();
                } else {
                    submissionState = { active: false, step: 0, data: {} };
                    addMessage("âŒ Annulleret. Skriv 'tilfÃ¸j event' for at prÃ¸ve igen! ğŸ˜Š", "bot");
                }
            }
        }
        
        async function submitEvent() {
            const submissionText = `${submissionState.data.dato}, ${submissionState.data.tid}, ${submissionState.data.type}, ${submissionState.data.sted}, ${submissionState.data.by}`;
            
            console.log("ğŸ“¤ Sending guided submission:", submissionText);
            
            // Add as user message
            addMessage(submissionText, "user");
            
            showTyping(true);
            
            try {
                const response = await fetch(`${SCRIPT_URL}?message=${encodeURIComponent(submissionText)}&sessionId=${sessionId}`);
                
                console.log("ğŸ“¥ Response status:", response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                console.log("ğŸ“¥ Response data:", data);
                console.log("ğŸ“¥ Reply text:", data.reply);
                
                showTyping(false);
                addMessage(data.reply, "bot");
                
                // Reset state
                submissionState = { active: false, step: 0, data: {} };
                
            } catch (error) {
                showTyping(false);
                console.error("âŒ Submission error:", error);
                addMessage("âŒ Der skete en fejl ved indsendelse. PrÃ¸v igen eller skriv eventet direkte! ğŸ˜Š", "bot");
                submissionState = { active: false, step: 0, data: {} };
            }
        }

        function addMessage(text, sender) {
            const chat = document.getElementById("chat");
            const messageDiv = document.createElement("div");
            messageDiv.className = `message ${sender}`;

            const img = document.createElement("img");
            img.src = sender === "user" ? "user-icon.svg" : "dancemap-icon.png";
            img.alt = sender === "user" ? "User" : "Bot";

            const bubble = document.createElement("div");
            bubble.className = "bubble";
            
            const textWithLinks = text.replace(
                /(https?:\/\/[^\s]+)/g,
                '<a href="$1" target="_blank">$1</a>'
            );
            
            bubble.innerHTML = textWithLinks.replace(/\n/g, "<br>");

            messageDiv.appendChild(img);
            messageDiv.appendChild(bubble);
            chat.appendChild(messageDiv);

            chat.scrollTop = chat.scrollHeight;
        }

        function showTyping(show) {
            const typing = document.getElementById("typing");
            const chat = document.getElementById("chat");
            
            if (show) {
                typing.classList.add("active");
                chat.appendChild(typing);
                chat.scrollTop = chat.scrollHeight;
            } else {
                typing.classList.remove("active");
            }
        }
    </script>
</body>
</html> - // Google Apps Script - DanceMap AI v2.1 - BULLETPROOF! ğŸ›¡ï¸
// Features: Perfekt context memory, "flere" command, smart suggestions

const SHEET_ID = "1nECcg7qrlfvQabDaIhPheXeQ0gu4_fdaQ4FhIOjLT_k";
const SALSA_CALENDAR_ID = "salsadenmark@gmail.com";
const CACHE_HOURS = 24;
const PENDING_SHEET_NAME = "Pending"; // New sheet for user submissions

// Session memory - gemmer brugerens sidste sÃ¸gning OG results
// Bruger PropertiesService for at gemme mellem requests
function getSessionContext(sessionId) {
  const props = PropertiesService.getScriptProperties();
  const key = "session_" + sessionId;
  const data = props.getProperty(key);
  
  if (data) {
    try {
      return JSON.parse(data);
    } catch (e) {
      return { by: null, dansetype: null, lastResults: [], offset: 0 };
    }
  }
  
  return { by: null, dansetype: null, lastResults: [], offset: 0 };
}

function setSessionContext(sessionId, context) {
  const props = PropertiesService.getScriptProperties();
  const key = "session_" + sessionId;
  props.setProperty(key, JSON.stringify(context));
}

function doGet(e) {
  const message = e.parameter.message || "";
  const sessionId = e.parameter.sessionId || "default";
  
  try {
    const sheetEvents = getSheetEvents();
    const calendarEvents = getCachedCalendarEvents();
    
    let allEvents = [...sheetEvents, ...calendarEvents];
    
    // SMART dubletter fjernelse
    const uniqueEvents = [];
    const seen = new Set();
    
    allEvents.forEach(event => {
      const dato = String(event.Dato || event.date || '');
      const tid = String(event.Starttid || event.time || '').substring(0, 5);
      const sted = String(event.Sted || event.location || '');
      
      // Normalize venue for better duplicate detection
      const normalizedSted = sted.toLowerCase()
        .replace(/\s+/g, '') // Remove all spaces
        .replace(/[,.-]/g, ''); // Remove punctuation
      
      const dateOnly = dato.split(' ')[0].split('T')[0];
      const key = `${dateOnly}-${tid}-${normalizedSted}`;
      
      if (!seen.has(key)) {
        seen.add(key);
        uniqueEvents.push(event);
      } else {
        Logger.log(`ğŸ”„ Duplikat fjernet: ${event.Dansetype || event.title} kl. ${tid}`);
      }
    });
    
    Logger.log(`ğŸ“Š Total events: ${uniqueEvents.length}`);
    
    // Generer smart response med context
    const reply = generateSmartResponse(message, uniqueEvents, sessionId);
    
    return ContentService
      .createTextOutput(JSON.stringify({ reply: reply }))
      .setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    Logger.log("Error: " + error);
    return ContentService
      .createTextOutput(JSON.stringify({ 
        reply: "Beklager, der skete en fejl. PrÃ¸v igen senere." 
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// Cached calendar events
function getCachedCalendarEvents() {
  const cache = CacheService.getScriptCache();
  const cached = cache.get("salsa_calendar");
  
  if (cached) {
    Logger.log("âœ… Bruger cached calendar data");
    return JSON.parse(cached);
  }
  
  Logger.log("âš ï¸ Cache udlÃ¸bet - henter ny data");
  const events = getSalsaCalendarEvents();
  cache.put("salsa_calendar", JSON.stringify(events), 86400);
  return events;
}

function getSalsaCalendarEvents() {
  try {
    const delay = Math.floor(Math.random() * 5000) + 3000;
    Utilities.sleep(delay);
    
    const calendar = CalendarApp.getCalendarById(SALSA_CALENDAR_ID);
    if (!calendar) return [];
    
    const now = new Date();
    const fourMonthsLater = new Date(now.getTime() + 120 * 24 * 60 * 60 * 1000);
    const calendarEvents = calendar.getEvents(now, fourMonthsLater);
    
    Logger.log("âœ… Fandt " + calendarEvents.length + " calendar events");
    
    const expandedEvents = [];
    
    calendarEvents.forEach(event => {
      const startTime = event.getStartTime();
      const location = event.getLocation() || "";
      const title = event.getTitle();
      const description = event.getDescription() || "";
      
      let by = extractCity(location + " " + description);
      let dansetype = title; // Keep full title by default
      
      // Only simplify if it's a generic title
      const lowerTitle = title.toLowerCase();
      if (lowerTitle === "salsa" || lowerTitle === "bachata" || lowerTitle === "kizomba") {
        // Generic title - keep as is
        dansetype = title;
      } else if (lowerTitle.includes("salsa") && lowerTitle.includes("bachata")) {
        // Has both - keep full title
        dansetype = title;
      } else {
        // Keep full title for specific events like "CHRISTMAS CSA Latin Social"
        dansetype = title;
      }
      
      // CLEAN location data - AGGRESSIVE cleaning
      let cleanedLocation = location;
      if (cleanedLocation) {
        // First: Remove everything after and including postal code
        cleanedLocation = cleanedLocation.replace(/\d{4}.*$/g, '');
        
        // Remove "SE-" prefix (Swedish postal codes)
        cleanedLocation = cleanedLocation.replace(/SE-\d+.*$/g, '');
        
        // Clean up trailing commas and spaces
        cleanedLocation = cleanedLocation.replace(/,\s*$/g, '');
        cleanedLocation = cleanedLocation.replace(/\s+/g, ' ');
        cleanedLocation = cleanedLocation.trim();
      }
      
      expandedEvents.push({
        Dansetype: dansetype,
        Dato: Utilities.formatDate(startTime, "Europe/Copenhagen", "yyyy-MM-dd HH:mm"),
        Starttid: Utilities.formatDate(startTime, "Europe/Copenhagen", "HH:mm"),
        Sted: cleanedLocation || location,
        By: by,
        source: "salsa.dk"
      });
    });
    
    return expandedEvents;
  } catch (error) {
    Logger.log("âŒ Calendar fejl: " + error);
    return [];
  }
}

function extractCity(text) {
  const cities = [
    "kÃ¸benhavn", "kbh", "frederiksberg", "nÃ¸rrebro", "Ã¸sterbro", "vesterbro", "amager",
    "aarhus", "Ã¥rhus", "aalborg", "Ã¥lborg", "odense", "esbjerg", "randers",
    "kolding", "vejle", "horsens", "roskilde", "helsingÃ¸r", "nÃ¦stved", "viborg",
    "silkeborg", "herning", "fredericia", "kÃ¸ge"
  ];
  
  const lowerText = text.toLowerCase();
  
  for (let city of cities) {
    if (lowerText.includes(city)) {
      return city.charAt(0).toUpperCase() + city.slice(1);
    }
  }
  
  return "Danmark";
}

function getSheetEvents() {
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const sheet = ss.getSheetByName("Events");
    if (!sheet) return [];
    
    const data = sheet.getDataRange().getValues();
    if (data.length === 0) return [];
    
    const headers = data.shift();
    
    return data.map(row => {
      let obj = { source: 'sheet' };
      headers.forEach((header, index) => {
        obj[header] = row[index];
      });
      return obj;
    }).filter(event => {
      return event.Dato || event.date || event.Dansetype || event.title;
    });
  } catch (err) {
    Logger.log("âŒ Sheet error: " + err);
    return [];
  }
}

// ============================================
// ğŸ§  BULLETPROOF SMART NLP & RESPONSE GENERATOR
// ============================================

function generateSmartResponse(message, events, sessionId) {
  const msg = message.toLowerCase().trim();
  
  if (events.length === 0) {
    return "Jeg kunne desvÃ¦rre ikke finde nogle events lige nu. PrÃ¸v igen senere!";
  }
  
  // Hent session context
  let context = getSessionContext(sessionId);
  
  // Check for "flere" command
  if (msg === "flere" || msg === "more" || msg === "vis flere") {
    if (context.lastResults && context.lastResults.length > 0) {
      context.offset += 10;
      const moreEvents = context.lastResults.slice(context.offset, context.offset + 10);
      
      if (moreEvents.length === 0) {
        return "Det var alle events! ğŸ‰ PrÃ¸v at sÃ¸ge efter noget andet.";
      }
      
      setSessionContext(sessionId, context);
      return formatEventResponse(moreEvents, context.lastIntent, context.lastResults.length, context.offset);
    } else {
      return "SÃ¸g efter events fÃ¸rst! PrÃ¸v fx 'salsa i kÃ¸benhavn' ğŸ˜Š";
    }
  }
  
  // Parse user intent
  const intent = parseIntent(msg);
  Logger.log("ğŸ§  Intent: " + JSON.stringify(intent));
  
  // SMART CONTEXT: Hvis brugeren IKKE specificerer by/dansetype, brug context
  if (context.by && !intent.by && intent.type === "search") {
    intent.by = context.by;
    Logger.log("ğŸ§  Bruger context by: " + intent.by);
  }
  
  if (context.dansetype && !intent.dansetype && intent.type === "search") {
    // Kun hvis de ikke specifikt spÃ¸rger om en ANDEN dansetype
    if (!msg.includes("salsa") && !msg.includes("bachata") && !msg.includes("kizomba")) {
      intent.dansetype = context.dansetype;
      Logger.log("ğŸ§  Bruger context dansetype: " + intent.dansetype);
    }
  }
  
  // Hilsner
  if (intent.type === "greeting") {
    return "Hej! ğŸ‘‹ Jeg kan hjÃ¦lpe dig finde dance events i Danmark.\n\nSpÃ¸rg mig fx:\nâ€¢ 'Salsa i KÃ¸benhavn i aften'\nâ€¢ 'Bachata denne weekend'\nâ€¢ 'Hvad sker der?'\n\nHvad vil du gerne danse? ğŸ’ƒ";
  }
  
  // Help
  if (intent.type === "help") {
    return "Jeg finder salsa, bachata og kizomba events for dig! ğŸ‰\n\nJeg forstÃ¥r spÃ¸rgsmÃ¥l som:\nâ€¢ 'Salsa i KÃ¸benhavn i dag'\nâ€¢ 'Bachata events denne uge'\nâ€¢ 'Hvad kan jeg lave i weekenden?'\nâ€¢ 'Gratis events'\n\nBare spÃ¸rg naturligt! ğŸ˜Š";
  }
  
  // Submit event prompt
  if (intent.type === "submit_prompt") {
    return "ğŸ“ **Indsend event!**\n\n" +
           "Send mig disse oplysninger:\n\n" +
           "ğŸ“… Dato: (fx '6. december' eller '2024-12-06')\n" +
           "ğŸ• Tidspunkt: (fx '20:00')\n" +
           "ğŸ’ƒ Type: (Salsa/Bachata/Kizomba)\n" +
           "ğŸ“ Sted: (fx 'Nordhus')\n" +
           "ğŸ“ Adresse: (fx 'Ã…rhusgade 124A')\n" +
           "ğŸ™ï¸ By: (fx 'KÃ¸benhavn')\n" +
           "ğŸ« Link: (valgfrit - Facebook/Billetto link)\n\n" +
           "Skriv det bare i Ã©n besked, jeg finder ud af resten! ğŸ˜Š";
  }
  
  // Generel oversigt
  if (intent.type === "overview") {
    const result = showUpcomingEvents(events, 10);
    return result;
  }
  
  // Hvis query er uforstÃ¥elig eller for kort - giv hjÃ¦lp!
  if (msg.length < 3 || (!intent.dansetype && !intent.by && !intent.timeframe && intent.type === "search")) {
    return "ğŸ¤” Jeg forstod ikke helt. PrÃ¸v fx:\n\n" +
           "â€¢ 'Salsa i KÃ¸benhavn'\n" +
           "â€¢ 'Bachata i weekenden'\n" +
           "â€¢ 'Hvad sker der i dag?'\n" +
           "â€¢ 'Vis alle events'\n\n" +
           "Eller skriv 'hjÃ¦lp' for flere eksempler! ğŸ˜Š";
  }
  
  // Check if message looks like event submission
  const submissionKeywords = ['dato:', 'tidspunkt:', 'kl.', 'sted:', 'adresse:', 'type:', 'link:', 'facebook.com', 'billetto'];
  const hasSubmissionKeywords = submissionKeywords.some(kw => msg.includes(kw));
  
  // Or if it has a date pattern and location info
  const hasDatePattern = msg.match(/\d{1,2}\.?\s*(jan|feb|mar|apr|maj|jun|jul|aug|sep|okt|nov|dec|januar|februar|marts|april|maj|juni|juli|august|september|oktober|november|december)/i);
  const hasTimePattern = msg.match(/\d{1,2}[:\.]\d{2}/);
  
  if (hasSubmissionKeywords || (hasDatePattern && hasTimePattern)) {
    const submissionResult = tryParseAndSubmitEvent(message);
    return submissionResult;
  }
  
  // Filter events baseret pÃ¥ intent
  let filteredEvents = filterEventsByIntent(events, intent);
  
  // Hvis ingen results - giv intelligente forslag
  if (filteredEvents.length === 0) {
    return handleNoResults(events, intent, context);
  }
  
  // Sort by date
  filteredEvents.sort((a, b) => {
    const dateA = parseEventDate(a.Dato || a.date) || new Date(0);
    const dateB = parseEventDate(b.Dato || b.date) || new Date(0);
    return dateA - dateB;
  });
  
  // GEM CONTEXT for nÃ¦ste gang (VIGTIGT!)
  if (intent.by) context.by = intent.by;
  if (intent.dansetype) context.dansetype = intent.dansetype;
  context.lastResults = filteredEvents;
  context.lastIntent = intent;
  context.offset = 0; // Reset offset
  setSessionContext(sessionId, context);
  
  Logger.log("ğŸ’¾ Gemt context: by=" + context.by + ", dansetype=" + context.dansetype);
  
  // Format response (vis fÃ¸rste 10)
  let response = formatEventResponse(filteredEvents.slice(0, 10), intent, filteredEvents.length, 0);
  
  // TilfÃ¸j smart follow-up forslag (MED CONTEXT!)
  response += generateFollowUpSuggestions(filteredEvents, intent, context);
  
  return response;
}

// Parse user intent fra natural language
function parseIntent(msg) {
  const intent = {
    type: "search",
    by: null,
    dansetype: null,
    timeframe: null,
    pris: null
  };
  
  // Greeting detection
  if (msg.match(/^(hej|hey|hi|hallo|goddag|yo)$/)) {
    intent.type = "greeting";
    return intent;
  }
  
  // Help detection
  if (msg.includes("hvad kan du") || msg.includes("help") || msg.includes("hjÃ¦lp")) {
    intent.type = "help";
    return intent;
  }
  
  // Submit event detection
  if (msg.includes("tilfÃ¸j event") || msg.includes("submit event") || 
      msg.includes("mangler event") || msg.includes("indsend event") ||
      msg.includes("jeg kender et event") || msg.includes("nyt event")) {
    intent.type = "submit_prompt";
    return intent;
  }
  
  // Overview detection
  if (msg.includes("hvad sker") || msg.includes("vis events") || msg === "events") {
    intent.type = "overview";
    return intent;
  }
  
  // Natural language patterns for time
  if (msg.match(/(i aften|tonight|i dag|idag)/)) {
    intent.timeframe = "today";
  } else if (msg.match(/(i morgen|imorgen|tomorrow)/)) {
    intent.timeframe = "tomorrow";
  } else if (msg.match(/(weekend|weekenden|lÃ¸rdag|sÃ¸ndag)/)) {
    intent.timeframe = "weekend";
  } else if (msg.match(/(denne uge|ugen|this week)/)) {
    intent.timeframe = "week";
  } else if (msg.match(/(denne mÃ¥ned|mÃ¥neden|this month)/)) {
    intent.timeframe = "month";
  }
  
  // Month detection
  const monthMap = {
    "januar": 0, "februar": 1, "marts": 2, "april": 3, "maj": 4, "juni": 5,
    "juli": 6, "august": 7, "september": 8, "oktober": 9, "november": 10, "december": 11
  };
  
  for (const [monthName, monthIndex] of Object.entries(monthMap)) {
    if (msg.includes(monthName)) {
      intent.timeframe = "month:" + monthIndex;
      break;
    }
  }
  
  // Dansetype detection
  if (msg.match(/salsa/) && !msg.match(/bachata/)) {
    intent.dansetype = "salsa";
  } else if (msg.match(/bachata/) && !msg.match(/salsa/)) {
    intent.dansetype = "bachata";
  } else if (msg.match(/kizomba/)) {
    intent.dansetype = "kizomba";
  } else if (msg.match(/salsa.*bachata|bachata.*salsa/)) {
    intent.dansetype = "both";
  }
  
  // By detection
  const cityMap = {
    kÃ¸benhavn: ["kÃ¸benhavn", "kbh", "cph", "kÃ¸ben", "frederiks", "nÃ¸rrebro", "Ã¸sterbro", "vesterbro", "amager"],
    aarhus: ["aarhus", "Ã¥rhus"],
    aalborg: ["aalborg", "Ã¥lborg"],
    odense: ["odense"]
  };
  
  for (const [city, keywords] of Object.entries(cityMap)) {
    if (keywords.some(keyword => msg.includes(keyword))) {
      intent.by = city;
      break;
    }
  }
  
  // Pris detection
  if (msg.match(/gratis|free|ingen pris/)) {
    intent.pris = "gratis";
  }
  
  return intent;
}

function filterEventsByIntent(events, intent) {
  let filtered = events;
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  // Fjern gamle events
  filtered = filtered.filter(e => {
    const eventDate = parseEventDate(e.Dato || e.date);
    return eventDate && eventDate >= today;
  });
  
  // Filter pÃ¥ tid
  if (intent.timeframe) {
    if (intent.timeframe === "today") {
      const todayStr = Utilities.formatDate(today, "Europe/Copenhagen", "yyyy-MM-dd");
      filtered = filtered.filter(e => {
        const eventDate = formatEventDate(e.Dato || e.date);
        return eventDate === todayStr;
      });
    } else if (intent.timeframe === "tomorrow") {
      const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);
      const tomorrowStr = Utilities.formatDate(tomorrow, "Europe/Copenhagen", "yyyy-MM-dd");
      filtered = filtered.filter(e => {
        const eventDate = formatEventDate(e.Dato || e.date);
        return eventDate === tomorrowStr;
      });
    } else if (intent.timeframe === "weekend") {
      filtered = filtered.filter(e => {
        const eventDate = parseEventDate(e.Dato || e.date);
        if (!eventDate) return false;
        const dayOfWeek = eventDate.getDay();
        return dayOfWeek === 5 || dayOfWeek === 6 || dayOfWeek === 0;
      });
    } else if (intent.timeframe === "week") {
      const weekLater = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
      filtered = filtered.filter(e => {
        const eventDate = parseEventDate(e.Dato || e.date);
        if (!eventDate) return false;
        return eventDate >= today && eventDate <= weekLater;
      });
    } else if (intent.timeframe === "month") {
      const currentMonth = today.getMonth();
      const currentYear = today.getFullYear();
      filtered = filtered.filter(e => {
        const eventDate = parseEventDate(e.Dato || e.date);
        if (!eventDate) return false;
        return eventDate.getMonth() === currentMonth && eventDate.getFullYear() === currentYear;
      });
    } else if (intent.timeframe.startsWith("month:")) {
      const monthIndex = parseInt(intent.timeframe.split(":")[1]);
      filtered = filtered.filter(e => {
        const eventDate = parseEventDate(e.Dato || e.date);
        if (!eventDate) return false;
        return eventDate.getMonth() === monthIndex;
      });
    }
  }
  
  // Filter pÃ¥ dansetype
  if (intent.dansetype) {
    if (intent.dansetype === "both") {
      filtered = filtered.filter(e => {
        const dansetype = (e.Dansetype || e.title || "").toLowerCase();
        return dansetype.includes("salsa") || dansetype.includes("bachata");
      });
    } else {
      filtered = filtered.filter(e => {
        const dansetype = (e.Dansetype || e.title || "").toLowerCase();
        return dansetype.includes(intent.dansetype);
      });
    }
  }
  
  // Filter pÃ¥ by
  if (intent.by) {
    const cityKeywords = {
      kÃ¸benhavn: ["kÃ¸benhavn", "kbh", "frederiksberg", "nÃ¸rrebro", "Ã¸sterbro", "vesterbro", "amager"],
      aarhus: ["aarhus", "Ã¥rhus"],
      aalborg: ["aalborg", "Ã¥lborg"],
      odense: ["odense"]
    };
    
    const keywords = cityKeywords[intent.by] || [intent.by];
    filtered = filtered.filter(e => {
      const by = (e.By || e.by || e.location || "").toLowerCase();
      return keywords.some(keyword => by.includes(keyword));
    });
  }
  
  // Filter pÃ¥ pris
  if (intent.pris === "gratis") {
    filtered = filtered.filter(e => {
      const pris = (e.Pris || "").toLowerCase();
      return pris.includes("gratis") || pris.includes("free") || pris === "";
    });
  }
  
  return filtered;
}

function handleNoResults(allEvents, intent, context) {
  const today = new Date();
  const upcoming = allEvents.filter(e => {
    const eventDate = parseEventDate(e.Dato || e.date);
    return eventDate && eventDate >= today;
  }).sort((a, b) => {
    const dateA = parseEventDate(a.Dato || a.date) || new Date(0);
    const dateB = parseEventDate(b.Dato || b.date) || new Date(0);
    return dateA - dateB;
  });
  
  if (upcoming.length === 0) {
    return "Jeg har desvÃ¦rre ingen kommende events. PrÃ¸v igen senere! ğŸ“…";
  }
  
  const nextEvent = upcoming[0];
  const nextDate = parseEventDate(nextEvent.Dato || nextEvent.date);
  const whenText = formatWhenText(nextDate);
  
  let suggestion = `Jeg fandt desvÃ¦rre ingen events`;
  
  if (intent.dansetype) suggestion += ` med ${intent.dansetype}`;
  if (intent.by) suggestion += ` i ${intent.by}`;
  if (intent.timeframe) {
    // Convert timeframe to Danish
    const timeframeDa = {
      'today': 'i dag',
      'tomorrow': 'i morgen',
      'weekend': 'i weekenden',
      'week': 'denne uge',
      'month': 'denne mÃ¥ned'
    };
    suggestion += ` ${timeframeDa[intent.timeframe] || intent.timeframe}`;
  }
  
  suggestion += `.\n\nMen ${whenText} er der ${nextEvent.Dansetype} pÃ¥ ${nextEvent.Sted}`;
  if (nextEvent.By) suggestion += ` (${nextEvent.By})`;
  suggestion += `! ğŸ’ƒ\n\n`;
  
  // Add helpful suggestions
  suggestion += `ğŸ’¡ PrÃ¸v fx:\n`;
  suggestion += `â€¢ 'Vis alle events'\n`;
  if (intent.by) suggestion += `â€¢ 'Salsa i ${intent.by}' (uden tidsbegrÃ¦nsning)\n`;
  if (intent.dansetype) suggestion += `â€¢ '${intent.dansetype} i weekenden'\n`;
  if (!intent.by) suggestion += `â€¢ 'Events i KÃ¸benhavn'\n`;
  
  return suggestion;
}

function formatEventResponse(events, intent, totalCount, offset) {
  let response = "ğŸ‰ ";
  
  if (intent.dansetype) response += `${intent.dansetype.charAt(0).toUpperCase() + intent.dansetype.slice(1)} events`;
  else response += "Events";
  
  if (intent.by) response += ` i ${intent.by.charAt(0).toUpperCase() + intent.by.slice(1)}`;
  if (intent.timeframe && !intent.timeframe.startsWith("month:")) {
    response += ` ${intent.timeframe}`;
  }
  
  response += ":\n\n";
  
  events.forEach((event, i) => {
    const dansetype = event.Dansetype || event.title || "Event";
    const dato = event.Dato || event.date || "TBA";
    const starttid = event.Starttid || event.time || "";
    const sluttid = event.Sluttid || "";
    const sted = event.Sted || event.location || "";
    const adresse = event.Adresse || "";
    const by = event.By || event.by || "";
    const pris = event.Pris || "";
    
    const eventDate = parseEventDate(dato);
    let datoFormatted = dato;
    
    if (eventDate) {
      const weekdayDa = ["SÃ¸ndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "LÃ¸rdag"];
      const monthsDa = ["jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec"];
      const dayName = weekdayDa[eventDate.getDay()];
      const day = eventDate.getDate();
      const month = monthsDa[eventDate.getMonth()];
      datoFormatted = `${dayName} ${day}. ${month}`;
    }
    
    // Capitalize dansetype properly
    const capitalizedDansetype = dansetype.split(' ').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join(' ');
    
    // Build time string
    let timeStr = '';
    if (starttid) {
      timeStr = ` kl. ${starttid}`;
      if (sluttid && sluttid !== "00:00" && sluttid !== "00.00" && sluttid !== "") {
        timeStr += `-${sluttid}`;
      }
    }
    
    // First line: Date + Time + Dance Type
    response += `${datoFormatted}${timeStr} - ${capitalizedDansetype}\n`;
    
    // Second line: Location (City first if exists, then venue/address)
    let locationLine = 'ğŸ“ ';
    
    // Capitalize city properly
    const capitalizedCity = by ? by.charAt(0).toUpperCase() + by.slice(1).toLowerCase() : '';
    
    if (capitalizedCity && capitalizedCity !== 'Danmark') {
      locationLine += `${capitalizedCity} - `;
    }
    
    // Add venue and address (COMPLETELY cleaned)
    let locationParts = [];
    
    if (sted && sted.trim()) {
      locationParts.push(sted.trim());
    }
    
    if (adresse && adresse.trim() && adresse.trim() !== sted.trim()) {
      let cleanAddress = adresse.trim();
      
      // Remove postal codes (4 digits)
      cleanAddress = cleanAddress.replace(/\d{4}/g, '');
      
      // Remove "KÃ¸benhavn N/S/Ã˜/V" etc.
      cleanAddress = cleanAddress.replace(/KÃ¸benhavn\s*[NSÃ˜V]?/gi, '');
      cleanAddress = cleanAddress.replace(/Aarhus\s*[NSÃ˜V]?/gi, '');
      cleanAddress = cleanAddress.replace(/Aalborg\s*[NSÃ˜V]?/gi, '');
      cleanAddress = cleanAddress.replace(/Odense\s*[NSÃ˜V]?/gi, '');
      
      // Remove "Denmark" or "Danmark"
      cleanAddress = cleanAddress.replace(/,?\s*Denmark$/gi, '');
      cleanAddress = cleanAddress.replace(/,?\s*Danmark$/gi, '');
      
      // Remove multiple commas and spaces
      cleanAddress = cleanAddress.replace(/,\s*,/g, ',');
      cleanAddress = cleanAddress.replace(/\s+,/g, ',');
      cleanAddress = cleanAddress.replace(/,\s+$/g, '');
      cleanAddress = cleanAddress.replace(/^\s*,/g, '');
      cleanAddress = cleanAddress.trim();
      
      // Only add if there's something left and it's different from venue
      if (cleanAddress && cleanAddress !== sted.trim() && cleanAddress.length > 0) {
        locationParts.push(cleanAddress);
      }
    }
    
    if (locationParts.length > 0) {
      locationLine += locationParts.join(', ');
    }
    
    response += `${locationLine}\n`;
    
    // Optional: Price line (if exists)
    if (pris && pris.trim()) {
      response += `ğŸ’° ${pris}\n`;
    }
    
    response += `\n`;
  });
  
  // BULLETPROOF "flere" besked
  const remaining = totalCount - offset - events.length;
  if (remaining > 0) {
    response += `ğŸ“‹ Viser ${offset + 1}-${offset + events.length} af ${totalCount} events\n`;
    response += `ğŸ’¬ Skriv 'flere' for at se de nÃ¦ste ${Math.min(remaining, 10)} events\n\n`;
  } else if (totalCount > 10) {
    response += `ğŸ“‹ Det var alle ${totalCount} events! ğŸ‰\n\n`;
  }
  
  return response;
}

function generateFollowUpSuggestions(events, intent, context) {
  let suggestions = "ğŸ’¡ ";
  const addedSuggestions = [];
  
  // Hvis de sÃ¸gte salsa, foreslÃ¥ bachata (MED SAMME BY!)
  if (intent.dansetype === "salsa" && context.by) {
    addedSuggestions.push(`Vil du se bachata i ${context.by.charAt(0).toUpperCase() + context.by.slice(1)}? Skriv 'bachata'`);
  } else if (intent.dansetype === "bachata" && context.by) {
    addedSuggestions.push(`Vil du se salsa i ${context.by.charAt(0).toUpperCase() + context.by.slice(1)}? Skriv 'salsa'`);
  }
  
  // Hvis de sÃ¸gte i specifik by, foreslÃ¥ anden by
  if (intent.by === "kÃ¸benhavn") {
    const aarhusCount = events.filter(e => (e.By || "").toLowerCase().includes("aarhus")).length;
    if (aarhusCount > 0) {
      addedSuggestions.push(`${aarhusCount} events i Aarhus`);
    }
  }
  
  // Hvis de sÃ¸gte i dag, foreslÃ¥ i morgen
  if (intent.timeframe === "today") {
    addedSuggestions.push(`PrÃ¸v 'i morgen' for flere events`);
  }
  
  if (addedSuggestions.length > 0) {
    suggestions += addedSuggestions.join(" â€¢ ");
    return "\n" + suggestions;
  }
  
  return "";
}

// Helper functions
function parseEventDate(dateValue) {
  if (!dateValue) return null;
  try {
    if (dateValue instanceof Date) return dateValue;
    if (typeof dateValue === 'string') {
      const dateStr = dateValue.split('T')[0].split(' ')[0];
      return new Date(dateStr);
    }
    return new Date(dateValue);
  } catch (e) {
    return null;
  }
}

function formatEventDate(dateValue) {
  const date = parseEventDate(dateValue);
  if (!date) return "";
  return Utilities.formatDate(date, "Europe/Copenhagen", "yyyy-MM-dd");
}

function formatWhenText(date) {
  if (!date) return "snart";
  
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const eventDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const diffDays = Math.floor((eventDay - today) / (1000 * 60 * 60 * 24));
  
  const weekdayDa = ["sÃ¸ndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lÃ¸rdag"];
  const monthsDa = ["jan", "feb", "mar", "apr", "maj", "jun", "jul", "aug", "sep", "okt", "nov", "dec"];
  
  if (diffDays === 0) return "i dag";
  if (diffDays === 1) return "i morgen";
  if (diffDays === 2) return "i overmorgen";
  if (diffDays <= 6) return weekdayDa[date.getDay()];
  
  return `${weekdayDa[date.getDay()]} ${date.getDate()}. ${monthsDa[date.getMonth()]}`;
}

function showUpcomingEvents(events, limit) {
  const today = new Date();
  
  const upcoming = events.filter(e => {
    const eventDate = parseEventDate(e.Dato || e.date);
    return eventDate && eventDate >= today;
  }).sort((a, b) => {
    const dateA = parseEventDate(a.Dato || a.date) || new Date(0);
    const dateB = parseEventDate(b.Dato || b.date) || new Date(0);
    return dateA - dateB;
  });
  
  if (upcoming.length === 0) {
    return "Der er desvÃ¦rre ingen kommende events lige nu.";
  }
  
  return formatEventResponse(upcoming.slice(0, limit), { type: "overview" }, upcoming.length, 0) + "\nğŸ’ƒ SpÃ¸rg efter specifikke events! ğŸ•º";
}
// ============================================
// ğŸ« AUTOMATIC TICKET LINK SCRAPER
// TilfÃ¸j denne kode til BUNDEN af din dancemap-bulletproof.js
// ============================================

// Kendte billetplatforme
const TICKET_PLATFORMS = {
  'billetto.dk': 'Billetto',
  'billetto.com': 'Billetto',
  'facebook.com/events': 'Facebook',
  'fb.me': 'Facebook',
  'ticketmaster.dk': 'Ticketmaster',
  'eventbrite.dk': 'Eventbrite',
  'eventbrite.com': 'Eventbrite'
};

// Kendte arrangÃ¸r websites
const KNOWN_ORGANIZERS = {
  'Copenhagen Salsa Academy': 'https://copenhagensalsaacademy.dk',
  'CSA': 'https://copenhagensalsaacademy.dk',
  'Salsa Libre Copenhagen': 'https://salsalibre.dk',
  'Salsa Libre': 'https://salsalibre.dk',
  'Kizomba Copenhagen': 'https://www.kizombacopenhagen.com',
  'Next House Copenhagen': 'https://nexthousecopenhagen.com',
  'Dogville Salsa': 'https://dogvillesalsa.dk',
  'AK Dance': 'https://akdance.dk'
};

/**
 * HOVEDFUNKTION - KÃ¸r denne manuelt eller via trigger
 * Finder billetlinks for alle events uden links
 */
function findAllTicketLinks() {
  Logger.log("ğŸ« ===== STARTER BILLETLINK SCRAPING =====");
  
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const sheet = ss.getSheetByName("Events");
    
    if (!sheet) {
      Logger.log("âŒ Sheet 'Events' ikke fundet!");
      return;
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find kolonne indices
    const linkColIndex = headers.indexOf('Link');
    const arrangÃ¸rColIndex = headers.indexOf('ArrangÃ¸r');
    const dansetypeColIndex = headers.indexOf('Dansetype');
    const stedColIndex = headers.indexOf('Sted');
    
    if (linkColIndex === -1) {
      Logger.log("âŒ Kolonne 'Link' ikke fundet!");
      return;
    }
    
    let foundCount = 0;
    let checkedCount = 0;
    let skippedCount = 0;
    
    // GÃ¥ igennem alle events (start fra rÃ¦kke 2 for at skippe header)
    for (let i = 1; i < data.length && i < 50; i++) { // Max 50 events per kÃ¸rsel
      const row = data[i];
      const currentLink = row[linkColIndex];
      
      // Skip hvis der allerede er et link
      if (currentLink && currentLink.toString().trim() !== '') {
        skippedCount++;
        continue;
      }
      
      const arrangÃ¸r = row[arrangÃ¸rColIndex] || '';
      const dansetype = row[dansetypeColIndex] || '';
      const sted = row[stedColIndex] || '';
      
      if (!arrangÃ¸r && !sted) {
        continue; // Ikke nok info til at sÃ¸ge
      }
      
      checkedCount++;
      Logger.log(`\nğŸ” SÃ¸ger link for event #${i + 1}: ${dansetype} (${arrangÃ¸r})`);
      
      // PrÃ¸v at finde billetlink
      const ticketLink = findTicketLink(dansetype, arrangÃ¸r, sted);
      
      if (ticketLink) {
        // Opdater sheet
        sheet.getRange(i + 1, linkColIndex + 1).setValue(ticketLink);
        foundCount++;
        Logger.log(`âœ… Fandt og gemte link: ${ticketLink}`);
        
        // Vent lidt mellem requests for at vÃ¦re hÃ¸flig
        Utilities.sleep(2000);
      } else {
        Logger.log(`âš ï¸ Ingen link fundet`);
      }
    }
    
    Logger.log("\nğŸ“Š ===== RESULTATER =====");
    Logger.log(`âœ… Fandt nye links: ${foundCount}`);
    Logger.log(`ğŸ” Tjekkede events: ${checkedCount}`);
    Logger.log(`â­ï¸  Havde allerede link: ${skippedCount}`);
    Logger.log("ğŸ‰ ===== FÃ†RDIG =====");
    
  } catch (error) {
    Logger.log("âŒ FEJL: " + error);
  }
}

/**
 * Find billetlink for et specifikt event
 */
function findTicketLink(eventName, organizer, venue) {
  // Strategi 1: Check om arrangÃ¸r har kendt website
  if (organizer && KNOWN_ORGANIZERS[organizer]) {
    const link = scrapeOrganizerWebsite(KNOWN_ORGANIZERS[organizer], eventName);
    if (link) return link;
  }
  
  // Strategi 2: SÃ¸g pÃ¥ Google efter event + billetter
  const searchLink = searchForTicketLink(eventName, organizer, venue);
  if (searchLink) return searchLink;
  
  return null;
}

/**
 * Scrape arrangÃ¸rens website for billetlink
 */
function scrapeOrganizerWebsite(url, eventName) {
  try {
    const response = UrlFetchApp.fetch(url, {
      muteHttpExceptions: true,
      followRedirects: true
    });
    
    if (response.getResponseCode() !== 200) {
      return null;
    }
    
    const html = response.getContentText();
    
    // SÃ¸g efter billetplatforme i HTML
    for (const [platform, name] of Object.entries(TICKET_PLATFORMS)) {
      if (html.toLowerCase().includes(platform)) {
        // PrÃ¸v at ekstraktere specifikt link
        const linkMatch = extractLinkFromHtml(html, platform);
        if (linkMatch) {
          Logger.log(`   ğŸ“Œ Fandt ${name} link pÃ¥ ${url}`);
          return linkMatch;
        }
      }
    }
    
    return null;
  } catch (error) {
    Logger.log(`   âš ï¸ Kunne ikke scrape ${url}: ${error}`);
    return null;
  }
}

/**
 * EkstrahÃ©r specifikt link fra HTML
 */
function extractLinkFromHtml(html, platform) {
  // Simple regex til at finde URLs
  const urlRegex = new RegExp(`https?://[^\\s"'<>]*${platform.replace('.', '\\.')}[^\\s"'<>]*`, 'i');
  const match = html.match(urlRegex);
  
  if (match) {
    let url = match[0];
    // Rens URL
    url = url.replace(/[)}>"\]]+$/, ''); // Fjern trailing special chars
    return url;
  }
  
  return null;
}

/**
 * SÃ¸g efter billetlink via Google Custom Search
 * (Simpel version - kan forbedres med Custom Search API)
 */
function searchForTicketLink(eventName, organizer, venue) {
  try {
    // Byg sÃ¸gequery
    let query = '';
    if (eventName) query += eventName + ' ';
    if (organizer) query += organizer + ' ';
    query += 'billetter';
    
    // SÃ¸g efter kendte platforme
    const platforms = ['billetto.dk', 'facebook.com/events'];
    
    for (const platform of platforms) {
      const searchQuery = `${query} site:${platform}`;
      
      // Note: Dette er en simpel version
      // For bedre resultater, brug Google Custom Search API
      Logger.log(`   ğŸ” SÃ¸ger: ${searchQuery}`);
      
      // Her kunne vi bruge Google Custom Search API
      // For nu returnerer vi null og logger sÃ¸gningen
    }
    
    return null;
  } catch (error) {
    Logger.log(`   âš ï¸ SÃ¸gefejl: ${error}`);
    return null;
  }
}

/**
 * SETUP: Opret automatisk daglig trigger
 * KÃ¸r denne funktion Ã‰N GANG for at sÃ¦tte automatisering op
 */
function setupDailyTrigger() {
  // Fjern eksisterende triggers fÃ¸rst
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'findAllTicketLinks') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  // Opret ny trigger: KÃ¸r hver dag kl. 6:00
  ScriptApp.newTrigger('findAllTicketLinks')
    .timeBased()
    .atHour(6)
    .everyDays(1)
    .create();
  
  Logger.log("âœ… Automatisk daglig trigger oprettet! KÃ¸rer hver dag kl. 6:00");
}

/**
 * Fjern automatisk trigger
 */
function removeDailyTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'findAllTicketLinks') {
      ScriptApp.deleteTrigger(trigger);
      Logger.log("âœ… Automatisk trigger fjernet");
    }
  });
}

/**
 * TEST FUNKTION - Test pÃ¥ Ã©t event
 */
function testTicketScraper() {
  Logger.log("ğŸ§ª ===== TEST BILLETLINK SCRAPER =====");
  
  const testCases = [
    { name: "Salsa Night", organizer: "Copenhagen Salsa Academy", venue: "The Old Irish Pub" },
    { name: "Bachata Social", organizer: "Kizomba DK", venue: "CSA" },
    { name: "Salsa Fridays", organizer: "Salsa Libre Copenhagen", venue: "Kedelhallen" }
  ];
  
  testCases.forEach(test => {
    Logger.log(`\nğŸ” Test: ${test.name} by ${test.organizer}`);
    const link = findTicketLink(test.name, test.organizer, test.venue);
    if (link) {
      Logger.log(`âœ… Fandt: ${link}`);
    } else {
      Logger.log(`âš ï¸ Ingen link fundet`);
    }
  });
  
  Logger.log("\nğŸ‰ ===== TEST FÃ†RDIG =====");
}

// ============================================
// ğŸ“‹ SÃ…DAN BRUGER DU DET:
// ============================================
// 
// 1. MANUEL TEST:
//    KÃ¸r funktionen: testTicketScraper()
//    For at teste pÃ¥ dummy data
//
// 2. FIND LINKS FOR ALLE EVENTS:
//    KÃ¸r funktionen: findAllTicketLinks()
//    Finder links for max 50 events uden links
//
// 3. AUTOMATISER (EN GANG):
//    KÃ¸r funktionen: setupDailyTrigger()
//    SÃ¦tter automatisk daglig kÃ¸rsel op kl. 6:00
//
// 4. STOP AUTOMATISERING:
//    KÃ¸r funktionen: removeDailyTrigger()
//
// ============================================

// ============================================
// ğŸ§¹ UTILITY FUNCTIONS
// ============================================

/**
 * Clear Salsa.dk calendar cache
 * KÃ¸r denne nÃ¥r du vil have frisk data fra Salsa.dk
 */
function clearCache() {
  const cache = CacheService.getScriptCache();
  cache.remove("salsa_calendar");
  Logger.log("âœ… Cache cleared! NÃ¦ste request henter frisk data fra Salsa.dk");
}

/**
 * Clear ALL caches (inkl. session data)
 */
function clearAllCaches() {
  const cache = CacheService.getScriptCache();
  cache.removeAll(['salsa_calendar']);
  Logger.log("âœ… Alle caches cleared!");
}

/**
 * Force refresh - clear cache AND show what's scraped
 * Brug til debugging!
 */
function forceRefresh() {
  const cache = CacheService.getScriptCache();
  cache.removeAll(['salsa_calendar']);
  Logger.log("âœ… Cache cleared!");
  
  // Hent ny data med det samme
  const events = getSalsaCalendarEvents();
  Logger.log("ğŸ“Š Fandt " + events.length + " events");
  
  // Log fÃ¸rste 10 event navne
  Logger.log("\nğŸ“‹ Event navne:");
  events.slice(0, 10).forEach((e, i) => {
    Logger.log(`   ${i + 1}. ${e.Dansetype} - ${e.Sted}`);
  });
  
  Logger.log("\nâœ… Done! Test chatbot nu!");
}

/**
 * Manually approve all events marked "Godkendt"
 * Run this function to move approved events to Events sheet
 */
function manualApprove() {
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const pendingSheet = ss.getSheetByName("Pending");
  const eventsSheet = ss.getSheetByName("Events");
  
  if (!pendingSheet) {
    Logger.log("âŒ Pending sheet not found!");
    return;
  }
  
  if (!eventsSheet) {
    Logger.log("âŒ Events sheet not found!");
    return;
  }
  
  // Find all "Godkendt" rows
  const data = pendingSheet.getDataRange().getValues();
  const headers = data[0];
  const statusIndex = headers.indexOf('Status');
  
  if (statusIndex === -1) {
    Logger.log("âŒ Status column not found!");
    return;
  }
  
  Logger.log(`ğŸ“Š Found ${data.length - 1} rows in Pending`);
  Logger.log(`ğŸ“ Status column is at index ${statusIndex}`);
  
  let movedCount = 0;
  
  // Go through rows backwards (so deletion doesn't mess up indices)
  for (let i = data.length - 1; i > 0; i--) {
    const status = data[i][statusIndex];
    Logger.log(`ğŸ” Row ${i + 1}: Status = "${status}"`);
    
    if (status === 'Godkendt') {
      Logger.log(`âœ… Moving row ${i + 1}...`);
      
      // Copy to Events (remove Status column)
      const rowData = data[i].slice();
      rowData.splice(statusIndex, 1); // Remove Status column
      
      eventsSheet.appendRow(rowData);
      
      // Delete from Pending
      pendingSheet.deleteRow(i + 1);
      
      movedCount++;
      Logger.log(`âœ… Moved row ${i + 1} to Events!`);
    }
  }
  
  Logger.log(`\nğŸ‰ Done! Moved ${movedCount} events to Events sheet!`);
}

// ============================================
// ğŸ“ EVENT SUBMISSION SYSTEM
// ============================================

/**
 * Try to parse user message as event submission and add to sheet
 */
function tryParseAndSubmitEvent(message) {
  try {
    const eventData = parseEventSubmission(message);
    
    if (!eventData) {
      return "ğŸ¤” Jeg kunne ikke forstÃ¥ event informationen.\n\n" +
             "PrÃ¸v at inkludere:\n" +
             "â€¢ Dato (fx '6. december')\n" +
             "â€¢ Tidspunkt (fx '20:00')\n" +
             "â€¢ Type (Salsa/Bachata/Kizomba)\n" +
             "â€¢ Sted\n" +
             "â€¢ By\n\n" +
             "Eller skriv 'tilfÃ¸j event' for vejledning! ğŸ˜Š";
    }
    
    // Validate
    if (!eventData.Dato || !eventData.Dansetype || !eventData.Sted) {
      return "âŒ Mangler information!\n\n" +
             "Jeg skal bruge minimum:\n" +
             "â€¢ Dato\n" +
             "â€¢ Type (Salsa/Bachata/Kizomba)\n" +
             "â€¢ Sted\n\n" +
             "PrÃ¸v igen! ğŸ˜Š";
    }
    
    // Check for duplicates
    const duplicate = checkForDuplicate(eventData);
    if (duplicate) {
      return `âš ï¸ Dette event findes allerede!\n\n` +
             `ğŸ“… ${duplicate.Dansetype}\n` +
             `ğŸ• ${duplicate.Dato} ${duplicate.Starttid || ''}\n` +
             `ğŸ“ ${duplicate.Sted}` + (duplicate.By ? `, ${duplicate.By}` : '') + "\n\n" +
             `Tjek 'vis events' for at se det! ğŸ˜Š`;
    }
    
    // Add to Pending sheet
    const success = addEventToPending(eventData);
    
    if (success) {
      return "âœ… **Event indsendt!**\n\n" +
             `ğŸ“… ${eventData.Dansetype}\n` +
             `ğŸ• ${eventData.Dato} ${eventData.Starttid || ''}\n` +
             `ğŸ“ ${eventData.Sted}` + (eventData.By ? `, ${eventData.By}` : '') + "\n\n" +
             "Tak for hjÃ¦lpen! Eventet venter pÃ¥ godkendelse og vises snart! ğŸ‰";
    } else {
      return "âŒ Noget gik galt ved tilfÃ¸jelse af event.\n\n" +
             "PrÃ¸v igen eller kontakt support! ğŸ˜Š";
    }
    
  } catch (error) {
    Logger.log("âŒ Event submission error: " + error);
    return "âŒ Der skete en fejl. PrÃ¸v igen! ğŸ˜Š";
  }
}

/**
 * Parse event information from natural language
 */
function parseEventSubmission(message) {
  const msg = message.toLowerCase();
  const eventData = {};
  
  Logger.log("ğŸ“ Parsing submission: " + message);
  
  // Extract date - more flexible patterns
  const datePatterns = [
    /(\d{1,2})\.?\s*(januar|februar|marts|april|maj|juni|juli|august|september|oktober|november|december)/i,
    /(\d{1,2})\.?\s*(jan|feb|mar|apr|maj|jun|jul|aug|sep|okt|nov|dec)/i,
    /(\d{4})-(\d{2})-(\d{2})/,
    /(\d{1,2})\/(\d{1,2})/
  ];
  
  for (const pattern of datePatterns) {
    const match = message.match(pattern);
    if (match) {
      if (pattern === datePatterns[0] || pattern === datePatterns[1]) {
        // Danish format: "6. december" or "6. dec"
        const day = match[1];
        const monthMap = {
          'januar': '01', 'jan': '01',
          'februar': '02', 'feb': '02',
          'marts': '03', 'mar': '03',
          'april': '04', 'apr': '04',
          'maj': '05',
          'juni': '06', 'jun': '06',
          'juli': '07', 'jul': '07',
          'august': '08', 'aug': '08',
          'september': '09', 'sep': '09',
          'oktober': '10', 'okt': '10',
          'november': '11', 'nov': '11',
          'december': '12', 'dec': '12'
        };
        const monthStr = match[2].toLowerCase();
        const month = monthMap[monthStr];
        
        // Check if year is mentioned
        const yearMatch = message.match(/202[4-9]/);
        const year = yearMatch ? yearMatch[0] : new Date().getFullYear();
        
        eventData.Dato = `${year}-${month}-${day.padStart(2, '0')}`;
        Logger.log("âœ… Dato parsed: " + eventData.Dato);
      } else if (pattern === datePatterns[2]) {
        // ISO format: "2024-12-06"
        eventData.Dato = match[0];
        Logger.log("âœ… Dato parsed (ISO): " + eventData.Dato);
      }
      break;
    }
  }
  
  // Extract time - more flexible
  const timeMatch = message.match(/(\d{1,2})[:\.-](\d{2})/);
  if (timeMatch) {
    eventData.Starttid = `${timeMatch[1].padStart(2, '0')}:${timeMatch[2]}`;
    Logger.log("âœ… Tid parsed: " + eventData.Starttid);
  }
  
  // Extract dance type - check whole message
  if (msg.includes('salsa') && msg.includes('bachata')) {
    eventData.Dansetype = 'Salsa Bachata';
  } else if (msg.includes('salsa')) {
    eventData.Dansetype = 'Salsa';
  } else if (msg.includes('bachata')) {
    eventData.Dansetype = 'Bachata';
  } else if (msg.includes('kizomba')) {
    eventData.Dansetype = 'Kizomba';
  }
  
  if (eventData.Dansetype) {
    Logger.log("âœ… Dansetype parsed: " + eventData.Dansetype);
  }
  
  // Extract venue/location - look for capitalized words or after commas
  const parts = message.split(/[,\n]/);
  for (const part of parts) {
    const trimmed = part.trim();
    // Look for venue names (capitalized words)
    const venueMatch = trimmed.match(/\b([A-ZÃ†Ã˜Ã…][a-zÃ¦Ã¸Ã¥]+(?:\s+[A-ZÃ†Ã˜Ã…][a-zÃ¦Ã¸Ã¥]+)*)\b/);
    if (venueMatch && !eventData.Sted) {
      const candidate = venueMatch[0];
      // Skip common words
      if (!['Salsa', 'Bachata', 'Kizomba', 'Type', 'Dato', 'Sted', 'By', 'Link', 'Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'].includes(candidate)) {
        eventData.Sted = candidate;
        Logger.log("âœ… Sted parsed: " + eventData.Sted);
        break;
      }
    }
  }
  
  // Extract city
  const cities = ['kÃ¸benhavn', 'kbh', 'aarhus', 'aalborg', 'odense', 'frederiksberg', 'nÃ¸rdhavn', 'nÃ¸rrebro', 'vesterbro'];
  for (const city of cities) {
    if (msg.includes(city)) {
      eventData.By = city.charAt(0).toUpperCase() + city.slice(1);
      if (city === 'kbh') eventData.By = 'KÃ¸benhavn';
      Logger.log("âœ… By parsed: " + eventData.By);
      break;
    }
  }
  
  // Extract address - look for street patterns
  const addressMatch = message.match(/([A-ZÃ†Ã˜Ã…][a-zÃ¦Ã¸Ã¥]+(?:gade|vej|allÃ©|Boulevard|Plads|sgade|svej))\s*\d+[A-Z]?/i);
  if (addressMatch) {
    eventData.Adresse = addressMatch[0];
    Logger.log("âœ… Adresse parsed: " + eventData.Adresse);
  }
  
  // Extract link
  const linkMatch = message.match(/(https?:\/\/[^\s,]+)/i);
  if (linkMatch) {
    eventData.Link = linkMatch[1];
    Logger.log("âœ… Link parsed: " + eventData.Link);
  }
  
  Logger.log("ğŸ“Š Final parsed data: " + JSON.stringify(eventData));
  
  return eventData;
}

/**
 * Check if event already exists (duplicate detection)
 */
function checkForDuplicate(newEvent) {
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const sheet = ss.getSheetByName("Events");
    
    if (!sheet) return null;
    
    const data = sheet.getDataRange().getValues();
    if (data.length <= 1) return null; // Only header
    
    const headers = data[0];
    const datoIndex = headers.indexOf('Dato');
    const stedIndex = headers.indexOf('Sted');
    const tidIndex = headers.indexOf('Starttid');
    
    // Normalize function for comparison
    const normalize = (str) => {
      if (!str) return '';
      return String(str).toLowerCase().replace(/[^a-zÃ¦Ã¸Ã¥0-9]/g, '');
    };
    
    const newDate = newEvent.Dato ? newEvent.Dato.split(' ')[0] : '';
    const newTime = newEvent.Starttid ? newEvent.Starttid.substring(0, 5) : '';
    const newVenue = normalize(newEvent.Sted);
    
    // Check each existing event
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const existingDate = row[datoIndex] ? String(row[datoIndex]).split(' ')[0] : '';
      const existingTime = row[tidIndex] ? String(row[tidIndex]).substring(0, 5) : '';
      const existingVenue = normalize(row[stedIndex]);
      
      // Match if same date, similar time (within 30 min), and same venue
      if (existingDate === newDate && existingVenue === newVenue) {
        // Check time proximity
        if (newTime && existingTime) {
          const timeDiff = Math.abs(
            parseInt(newTime.split(':')[0]) * 60 + parseInt(newTime.split(':')[1]) -
            parseInt(existingTime.split(':')[0]) * 60 - parseInt(existingTime.split(':')[1])
          );
          
          if (timeDiff <= 30) {
            // It's a duplicate!
            let eventObj = {};
            headers.forEach((header, idx) => {
              eventObj[header] = row[idx];
            });
            return eventObj;
          }
        } else {
          // No time info, just check date + venue
          let eventObj = {};
          headers.forEach((header, idx) => {
            eventObj[header] = row[idx];
          });
          return eventObj;
        }
      }
    }
    
    return null; // No duplicate found
  } catch (error) {
    Logger.log("âŒ Duplicate check error: " + error);
    return null;
  }
}

/**
 * Add event to Pending sheet (awaiting approval)
 */
function addEventToPending(eventData) {
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    let sheet = ss.getSheetByName(PENDING_SHEET_NAME);
    
    // Create Pending sheet if it doesn't exist
    if (!sheet) {
      sheet = createPendingSheet(ss);
    }
    
    // Get headers from PENDING sheet (not Events!)
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    Logger.log("ğŸ“‹ Pending headers: " + headers.join(", "));
    
    // Create row data matching Pending headers
    const rowData = headers.map(header => {
      if (header === 'Status') return 'Pending';
      if (header === 'source') return 'user_submitted';
      return eventData[header] || '';
    });
    
    Logger.log("ğŸ“ Row data to add: " + JSON.stringify(rowData));
    
    // Append to Pending sheet
    sheet.appendRow(rowData);
    
    Logger.log("âœ… Event added to Pending: " + eventData.Dansetype + " at " + eventData.Sted);
    
    return true;
  } catch (error) {
    Logger.log("âŒ Error adding to Pending: " + error);
    Logger.log("âŒ Stack: " + error.stack);
    return false;
  }
}

/**
 * Create Pending sheet with proper structure
 */
function createPendingSheet(ss) {
  const sheet = ss.insertSheet(PENDING_SHEET_NAME);
  
  // Copy headers from Events sheet
  const eventsSheet = ss.getSheetByName("Events");
  const headers = eventsSheet.getRange(1, 1, 1, eventsSheet.getLastColumn()).getValues()[0];
  
  // Add Status column if not present
  if (!headers.includes('Status')) {
    headers.push('Status');
  }
  
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  
  // Format header row
  sheet.getRange(1, 1, 1, headers.length)
    .setBackground('#4a90e2')
    .setFontColor('#ffffff')
    .setFontWeight('bold');
  
  // Add dropdown for Status column
  const statusColumn = headers.indexOf('Status') + 1;
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(['Pending', 'Godkendt', 'Afvist'])
    .build();
  sheet.getRange(2, statusColumn, 1000).setDataValidation(rule);
  
  Logger.log("âœ… Created Pending sheet");
  
  return sheet;
}

/**
 * Auto-approve events when Status changes to "Godkendt"
 * Install this as an onEdit trigger
 */
function onEdit(e) {
  try {
    // Handle case where e is undefined (manual trigger test)
    if (!e || !e.source) {
      Logger.log("âš ï¸ onEdit called without event object");
      return;
    }
    
    const sheet = e.source.getActiveSheet();
    
    // Only process Pending sheet
    if (sheet.getName() !== PENDING_SHEET_NAME) return;
    
    const range = e.range;
    const row = range.getRow();
    const col = range.getColumn();
    
    // Check if Status column was edited
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const statusCol = headers.indexOf('Status') + 1;
    
    if (col === statusCol && row > 1) {
      const newStatus = range.getValue();
      
      Logger.log(`ğŸ“ Status changed to: ${newStatus} in row ${row}`);
      
      if (newStatus === 'Godkendt') {
        // Move to Events sheet
        moveToEvents(sheet, row);
        Logger.log("âœ… Event godkendt og flyttet!");
      } else if (newStatus === 'Afvist') {
        // Delete row
        sheet.deleteRow(row);
        Logger.log("âŒ Event afvist og slettet fra rÃ¦kke " + row);
      }
    }
  } catch (error) {
    Logger.log("âŒ onEdit error: " + error);
    Logger.log("âŒ Stack: " + error.stack);
  }
}

/**
 * Move event from Pending to Events sheet
 */
function moveToEvents(pendingSheet, row) {
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const eventsSheet = ss.getSheetByName("Events");
    
    // Get data from Pending sheet
    const rowData = pendingSheet.getRange(row, 1, 1, pendingSheet.getLastColumn()).getValues()[0];
    
    // Remove Status column data before adding to Events
    const headers = pendingSheet.getRange(1, 1, 1, pendingSheet.getLastColumn()).getValues()[0];
    const statusIndex = headers.indexOf('Status');
    if (statusIndex !== -1) {
      rowData.splice(statusIndex, 1);
    }
    
    // Add to Events sheet
    eventsSheet.appendRow(rowData);
    
    // Delete from Pending
    pendingSheet.deleteRow(row);
    
    Logger.log("âœ… Event godkendt og flyttet til Events sheet");
    
  } catch (error) {
    Logger.log("âŒ Move to Events error: " + error);
  }
}

/**
 * DEBUG FUNCTION - Test submission parsing
 */
function debugSubmission() {
  Logger.log("ğŸ§ª Test started");
  
  const testMessage = "10. december, 20:00, Salsa, Kedelhallen, KÃ¸benhavn";
  const result = tryParseAndSubmitEvent(testMessage);
  
  Logger.log("ğŸ“ Result: " + result);
}
